<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Learning | Kerri Miller]]></title>
  <link href="http://kerrizor.com/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://kerrizor.com/"/>
  <updated>2016-05-09T15:30:33-07:00</updated>
  <id>http://kerrizor.com/</id>
  <author>
    <name><![CDATA[Kerri Miller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Embracing the Abyss of Suspicion]]></title>
    <link href="http://kerrizor.com/blog/2016/03/22/embracing-the-abyss-of-suspicion/"/>
    <updated>2016-03-22T08:35:30-07:00</updated>
    <id>http://kerrizor.com/blog/2016/03/22/embracing-the-abyss-of-suspicion</id>
    <content type="html"><![CDATA[<p>It is &ldquo;simple&rdquo; in many ways to deconstruct an application.<!-- more --> We do this as a matter of course in many refactoring efforts, and whenever we&rsquo;re approaching an existing code base. We examine the pieces individually, or perhaps we trace through subsystems and interactions &ndash; this external action or detected state initiates this response in the code, prompting a cascade of effects and processes to themselves begin, often with a resulting calculation or response returns upwards out of the code.</p>

<p>..but what does it mean?</p>

<p>Code is written as a response to a human need. That need might be a report of profits and losses for the quarter, ordering queso deliveries at 3am, or delighting a child with edutainment, but these are all driven by a human wanting something. Naturally, the argument could be made that the world doesn&rsquo;t need &ldquo;Uber for cheese dip&rdquo; and while you&rsquo;d likely be correct, the human need in this case is driven by our economics; someone with money to invest has determined that the best use of their resources is to attempt to make a go out of on-demand fondue.</p>

<p>Code must exist outside of merely the mechanistic operation of a computer, and be valued within the context of it serving a given need. A piece of software that fails to meet this need can be said to be &ldquo;poor,&rdquo; and one that achieves it&rsquo;s goal to be &ldquo;good.&rdquo; This is especially true once we take into account the fact that code must also exist within a context of multiple human needs, which sometimes compete. The needs of end users, the needs of the business, the needs of the developers, but also the needs of the code itself as a distinctly human creation that must be tended and groomed as its contexts shifts &mdash; all these ends must be served.</p>

<p>Thus, if you can&rsquo;t consider what a thing <em>means</em>, and look only at what it <em>is</em>, you hobble your ability to understand the larger complex that thing exists within. Too often we work in a world of architects who generate reams of diagrams showing us the topology of a system. Valuable information, to be sure, and critical to the goal of architectural design, but too often there is precious little information about the <em>how</em> of a system, let alone the <em>why</em>. We are shown a static representation of the system, with no clues as to the flow of messages and interactions between it&rsquo;s parts in response to stimuli. In an effort to catalog and organize the units of a system, we fail to explore it&rsquo;s existence in Time, or tell the story of it&rsquo;s interactions with us.</p>

<p>As we observe the interplay between these forces, of the code attempting to fulfill demands, along with the demands shifting as the code satisfies needs and perhaps reveals needs previously unknown needs, our ability to reason increases as facts about the function and purpose are revealed. Just as sculptor can be said to not be fashioning a statue from marble so much as removing excess marble to reveal the statue hidden inside the block, code can be said to have an idealized state in which it could be said to be &ldquo;perfect&rdquo; in serving in balance all the demands which have been placed upon it.</p>

<p>Rationally, we recognize that this can never actually be true; code can never be perfect, as the context for it continually shifts. This brings to mind the process of evolution, creating never a perfect species, but only perfectly evolved species for their environment <strong>in this moment</strong>. This small distinction contains the recognition that as time progresses, demands shift, people come and go, and we continually learn more and more about our craft. Weeks or months go by, and our perfect statue no longer seems to have been fully exposed; there are bits of marble left to remove, subtleties to the human need that weren&rsquo;t served in our initial attempts that must now be addressed. As the environment changes, clinging to our beliefs about the relative correctness of the code without considering the new landscape of demands is a step towards technical doom.</p>

<h2>Testing</h2>

<p>We attempt to model our comprehension of the desire of the software with testing, to say &ldquo;this code suits what I know about this human need.&rdquo; Unit testing exists within the mechanistic state of &ldquo;what does this thing do?&rdquo; whereas integration or behavioral testing attempts to address the questions of &ldquo;<em>what</em> does this mean?&rdquo; and &ldquo;how does this software exist within a dynamic environment?&rdquo; As they strive to gain confidence and knowledge about literally the interactions and behaviors of objects, the begin to illuminate us as to the nature of the code within context. Both aspects must be examined, and it is a failure in ourselves that we can not bridge the gulf between these concepts &ndash; the static existence versus the dynamic. One common trait shared by more experienced developers is the ability to shift contextual viewpoint between these perspectives, to swap the ideology of the watchmaker-like world of unit testing, for the &ldquo;30,000 foot view&rdquo; ideology.</p>

<p>Each of these angles of testing directly serve to build a more detailed picture of the need we&rsquo;re attempting to satisfy, and the manner in which we&rsquo;re fulfilling it. As complexity grows however, it exposes the limits of our rationality. There simply exist too many states, too many interactions, for either our code <strong>or</strong> testing to be considered complete, and as more and more demands are placed upon the code, its purpose must ever more be at cross purposes with itself, its identity becoming muddled. How often have you built a pure API, only to realize that now you must add a reporting tool? ..an admin dashboard? ..some sort of data manipulation never once hinted at in the original problem statement? Rather than being &ldquo;confident,&rdquo; at best we can aspire to be &ldquo;comprehensive&rdquo; in our code and our tests, a word which itself is misleading and truthful, as if our testing could &ldquo;comprehend&rdquo; the code&rsquo;s possibilities, rather it is at best merely a representation of our limited knowledge of known fail states.</p>

<p>Code exists as instructions, a series of reactions to stimuli. Thus, an error case then represents something new, something that the code does not have a prearranged response to. A bug occurs and we are pushed into a place of discovery. We are presented with proof of our insufficiencies, either as developers making an inevitable, human mistake in syntax, control flow, or other &ldquo;duh&rdquo; errors, or in our understanding of the process required for code to successfully achieve the goal we had in creating it.</p>

<p>This land of discovery increases our ability to reason about the nature of software, both in terms of the immediate code and the code as it exists into the future. In a sense then, if we accept that code is an expression of our understanding, all code must then exist as a single code base or repo, across projects and jobs and technologies. We are the single constant, bringing our comprehension of the nature of computational instructions to bear when generating solutions to human needs, which themselves exists within the boundaries of humanity. By understanding the rationality of software, as well as the human context in which its created, you multiply your ability to craft solutions that are increasingly resilient &ndash; but still, never perfect.</p>

<p>It is in the challenging of our starting point, pushing us from stasis to growth, that wisdom can begin to emerge. We engage with the Hero&rsquo;s Journey and return with knowledge to slay the instance of failure, and our relationship to the wider context that has generated this failure is forever changed &ndash; fool me once can&rsquo;t fool me again</p>

<p>Slavoj Žižek said:</p>

<blockquote><p>Imagine ideology as a kind of filter, a frame, so that if you look at the same ordinary reality through that frame, everything changes. But in what sense? It&rsquo;s not that the frame actually adds anything. It&rsquo;s just that the frame opens the abyss of suspicion.</p></blockquote>

<p>This is the insufficiency of our ideology. We apply our carried ideology to the next task or project or technology, and we can change them in and out like the glasses. The ideologies we apply to code can change drastically, or mutate over time as we are exposed to success and failure. In many ways then, success is as harmful (even more so) than failure because success never prompts us to question the status quo.</p>

<p>I&rsquo;m a better developer not because I&rsquo;ve been strapped to a rocket and gotten high-fives on the way up, but specifically because I&rsquo;ve done so many dumb things, because I&rsquo;m constantly seeking to approach the fact of being a developer with different approaches and techniques &mdash; the dogma and ideologies of the developer. In a never ending process, I have built my built my ideology from observation, failure, and recovery &mdash; what is yours built from?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serendipity and Ruby Objects]]></title>
    <link href="http://kerrizor.com/blog/2015/05/14/serendipity-and-ruby-objects/"/>
    <updated>2015-05-14T10:38:12-07:00</updated>
    <id>http://kerrizor.com/blog/2015/05/14/serendipity-and-ruby-objects</id>
    <content type="html"><![CDATA[<p>One of the things that I explicitly try to model when I&rsquo;m teaching people is the idea that There Ain&rsquo;t No Such Thing As An Expert. <!-- more -->There are precious few people who know everything inside and out, and rather than try to puff myself up as some sort of magical repository of wisdom, it&rsquo;s better to model for students how to react to moments of discovering your knowledge isn&rsquo;t perfect, how to turn a surprise into a learning opportunity.</p>

<p>I often do Ruby training classes for groups and individuals, both for those who are new to Ruby as well as those who want to dive deeper into specific topics. During one of these training sessions, I loaded this chunk of Ruby into IRB:</p>

<p>```ruby
class Parent
  def speak</p>

<pre><code>puts "Pick up your room!"
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Parent
end
```</p>

<p>I&rsquo;m defining a <code>Parent</code> class with one instance method <code>speak</code> and a <code>Child</code> class that inherits from <code>Parent</code>, then I showed the students how method inheritance works in practice.</p>

<p><code>ruby
2.2.2 :009 &gt; Parent.new.speak
Pick up your room!
 =&gt; nil
2.2.2 :010 &gt; Child.new.speak
Pick up your room!
 =&gt; nil
</code></p>

<p>Next, I wanted to show how we could redefine the <code>speak</code> method for <code>Child</code>. As this was a group who, though junior, had previously developed in Java, I also wanted to show off a tiny bit of the Ruby magic, by accomplishing this not by restarting and loading up the objects again, but by reopening the class. Now, normally if I were to do that, I&rsquo;d type it in like this:</p>

<p><code>ruby
2.2.2 :011 &gt; class Child &lt; Parent
2.2.2 :012?&gt;   def speak
2.2.2 :013?&gt;     puts "YOU'RE NOT THE BOSS OF ME!"
2.2.2 :014?&gt;   end
2.2.2 :015?&gt; end
 =&gt; :speak
2.2.2 :016 &gt; Child.new.speak
YOU'RE NOT THE BOSS OF ME!
 =&gt; nil
</code></p>

<p>However, in my excitement to show how cool Ruby is, what I actually did was make a critical typo:</p>

<p><code>ruby
2.2.2 :017 &gt; Child &lt; Parent
 =&gt; true
</code></p>

<p>Wait, what?! Child is /less/ than Parent? That&rsquo;s interesting. Why would it be less than Parent? I was in the middle of a class, and didn&rsquo;t want to derail, so I quickly said &ldquo;Oh, that&rsquo;s interesting! I want to explore this later, hang on..&rdquo; As someone whose attention is easily diverted, I&rsquo;ve found having the code equivalent of a little notebook to jot down my thoughts, ideas, and questions to help me focus on the problem at hand rather than rabbit holes, so I keep a little folder of notes (backed by git) of interesting things.</p>

<p>So, questionable code captured, I as able to return to it later that evening. What was going on? Now, I know that all objects in Ruby have their own unique ID. Could that be what we&rsquo;re comparing?</p>

<p><code>ruby
2.2.2 :021 &gt; Child.object_id
 =&gt; 70157984875120
2.2.2 :022 &gt; Parent.object_id
 =&gt; 70157984897760
2.2.2 :023 &gt; Child.object_id &lt; Parent.object_id
 =&gt; true
</code></p>

<p>Possibly, except that I know that <code>&lt;</code>, just like <code>+</code>, is actually a method.</p>

<p><code>ruby
2.2.2 :024 &gt; 2.+(3)
 =&gt; 5
2.2.2 :025 &gt; 2 + 3
 =&gt; 5
2.2.2 :026 &gt; 2.+(3)
 =&gt; 5
2.2.2 :027 &gt; 2 &lt; 3
 =&gt; true
2.2.2 :028 &gt; 2.&lt;(3)
 =&gt; true
2.2.2 :029 &gt; Child.object_id.&lt;(Parent.object_id)
 =&gt; true
</code></p>

<p>It is only a syntactic convenience that we&rsquo;re able to use these operators in a more human friendly manner. So, when I&rsquo;m testing <code>Child.object_id &lt; Parent.object_id</code> my use of <code>&lt;</code> is a method on the object returned by <code>object_id</code>, which in this case if a FixNum.</p>

<p><code>ruby
2.2.2 :030 &gt; Child.object_id.class
 =&gt; Fixnum
</code></p>

<p>When I&rsquo;m comparing one class to another, I&rsquo;m using not some magical concept of &ldquo;less than&rdquo; that Ruby is aware of, but I&rsquo;m calling a method upon the return value of the previous method. Thankfully, Ruby offers us the ability to inquire where a given method is defined.</p>

<p><code>ruby
2.2.2 :031 &gt; Child.new.method(:speak).owner
 =&gt; Parent
2.2.2 :019 &gt; Child.method(:&lt;).owner
 =&gt; Module
</code></p>

<p>We see here that <code>speak</code> is defined as a method in <code>Parent</code> and thus handed down via inheritance to a <code>Child</code> instance, and that <code>&lt;</code>, as a class method of <code>Child</code>, is defined in <code>Module</code>.</p>

<p>So what exactly is it comparing? Off to <a href="http://ruby-doc.org/">http://ruby-doc.org</a> we go! It is a great resource, one that every Ruby developer should have bookmarked. You&rsquo;re not going to remember every single method, or how exactly each method behaves, so being comfortable with this documentation will pay off, and odds are you&rsquo;ll learn something new (or be reminded of something you forgot) every time you browse through it&rsquo;s pages.</p>

<p>Navigating to <a href="http://ruby-doc.org/core-2.2.2/Module.html">the page documenting Module</a> I found the following:</p>

<blockquote><p><strong>mod &lt; other → true, false, or nil</strong>
Returns true if mod is a subclass of other. Returns nil if there&rsquo;s no relationship between the two. (Think of the relationship in terms of the class definition: “class A&lt;B” implies “A&lt;B”.)</p></blockquote>

<p><em>&mdash; <a href="http://ruby-doc.org/core-2.2.2/Module.html#method-i-3C">Documentation for Module#&lt;</a></em></p>

<p>For our problem, we see that if the Class or Module on the left side of <code>&lt;</code> is a subclass of the Class or Module on the right side, we will get back <code>true</code>. If it is NOT a subclass, we will get back <code>false</code>, and if they&rsquo;re in no way related to each other, we&rsquo;ll get back <code>nil</code>. In the description above, we can see an abstract example to the left of the <em>→</em>, and to the right we see the possible outputs. On the actual Ruby-Docs.org website, you can also mouseover the definition to see a link &ldquo;click to toggle source&rdquo; which will reveal the actual source code that is run when you call the method. If you&rsquo;re curious &mdash; and I encourage you to be so &mdash; take a minute to open it up and see what&rsquo;s going on. You may not be able to write C, but I wager that you can read it and puzzle out how it works.</p>

<p>So this particular bit of Ruby isn&rsquo;t likely to be a big win for me; I can&rsquo;t imagine a terribly large number of situations in which I&rsquo;d need this functionality, but for that handful of cases, it is spectacularly useful.</p>

<h2>&ldquo;We learned a valuable lesson today&rdquo;</h2>

<p>More than just learning a bit of Ruby trivia, I hope this story shows a little about my process for learning.</p>

<h3>Spot the oddity, and move on</h3>

<p>Don&rsquo;t get distracted from the task you were attempting to accomplish. Time box yourself to 5 or 10 minutes, and if you haven&rsquo;t solved why it&rsquo;s behaving the way it is, but have an alternate solution, simply tuck the bizarre code away somewhere for future research.</p>

<h3>Create a hypothesis and experiment</h3>

<p>Use the tried and true Scientific Method. Think about the language you&rsquo;re working in normally behaves; what causes similar effects? What might be the behavior, given the outcome? Then consider how you could test that idea; if the language works the way you think it does, what would happen in the REPL if you changed an input value, or how you worked with the result?</p>

<h3>Read the docs</h3>

<p>It&rsquo;s rare to have a language, framework, or library without some kind of documentation. Identify what the best resources are for your particular case &ndash; online, desktop app like Dash, command-line man pages, or even documentation that ships inside a REPL. Learn how to read the documentation source you choose, how to search, navigate, and expand definitions, and read it when you&rsquo;re surprised by something, <em>even when you think you won&rsquo;t understand it.</em></p>

<h3>Imagine a reason or use case</h3>

<p>Once you&rsquo;ve learned how it behaves and played with it (either in a REPL or small mock-up script or application) try to imagine the use case for why this feature was built. What problems were other developers having that the language or framework&rsquo;s core team were attempting to address? Seeing the context of why you&rsquo;d use a particular feature helps to understand why it behaves the way it does.</p>

<h3>Share the knowledge</h3>

<p>Write up a blog post, tweet out a &ldquo;Did you know&hellip;&rdquo; gist, or even just talk about it with your peers on Slack or IRC. Sure, someone might say &ldquo;Oh, I can&rsquo;t believe you didn&rsquo;t know that&rdquo; but people who feign surprise are jerks and you should feel free to ignore this boorish behavior. Besides, no matter how new you are, it&rsquo;s likely that at least one other person DIDN&rsquo;T know about it or could use the reminder. Furthermore, you&rsquo;re the one who&rsquo;s trying to give back to the community by share the knowledge and teaching, so in the end it&rsquo;s you who is the awesome gold star developer, not them. Own it!</p>
]]></content>
  </entry>
  
</feed>
